import pandas as pd

from path_find import *
from src.algorithm.data_manager import data_loader
from src.lib.share import *

class Flight_Info:
    def __init__(self, loader):
        self.loader = loader  # 存储数据加载器的实例

    def get_flights_for_paths(self, paths):
        all_flight_info = []
        for path in paths:
            flight_info = self.get_flights_between_cities(path)  # 获取航班信息
            all_flight_info.append(flight_info)  # 添加每条路径的航班信息
        return all_flight_info

    def get_flights_between_cities(self, path):
        all_flights = []  # 用于存储该路径下的所有航班信息

        for i in range(len(path) - 1):
            city_A = path[i]
            city_B = path[i + 1]

            # 获取所有航班信息
            if city_A in self.loader.flights and city_B in self.loader.flights[city_A]:
                flights = self.loader.flights[city_A][city_B]
                all_flights.extend(flights)  # 添加航班信息
            all_flights.extend([1])
        return all_flights  # 返回所有航班信息


class Info:
    def __init__(self, loader):
        self.graph = None
        self.loader = loader  # 存储数据加载器的实例
        self.flight_info = Flight_Info(loader)  # 实例化航班信息类

    def compute(self, a, b):
        self.graph = Graph(a, b)

    def sort(self):
        self.graph.backup.sort(key=lambda path: (len(path), path))

    def output(self):
        for res in self.graph.backup:
            self.graph.outputs(res)
            # 获取并输出该路径的所有航班信息
            flight_info_for_path = self.flight_info.get_flights_for_paths([res])
            if flight_info_for_path:  # 如果有航班信息，才输出
                for flights in flight_info_for_path:
                    for flight in flights:
                        print(flight)  # 输出航班信息


if __name__ == "__main__":
    directory = share.directory  # 替换为你的目录
    loader = data_loader(directory)  # 创建数据加载器实例
    loader.load_flights_info()  # 加载航班信息

    info = Info(loader)  # 创建 Info 实例，并传入数据加载器
    info.compute(15, 3)  # 计算路径
    info.sort()  # 排序路径
    info.output()  # 输出路径及其航班信息


def find(self):
    for res in self.graph.backup:
        self.graph.outputs(res)  # 输出当前路径
        flight_info_for_path = self.flight_info.get_flights_for_paths([res])

        # 存储当前部分的航班信息
        current_flights = []

        if flight_info_for_path:
            for flights in flight_info_for_path:
                for flight in flights:
                    if flight == 1:  # 遇到1，输出并清空当前部分
                        # 在这里处理当前部分的信息，比如输出或存储
                        print("当前部分航班信息:")
                        for f in current_flights:
                            dep_time = f[0]
                            arr_time = f[3]
                            a1, a2 = dep_time.hour, dep_time.minute
                            b1, b2 = arr_time.hour, arr_time.minute
                            print(f"出发时间: {a1}:{a2}, 到达时间: {b1}:{b2}")

                        current_flights.clear()  # 清空当前部分
                    else:
                        # 存储航班信息
                        current_flights.append(flight)


[[[500, 625], [500, 620], [535, 640], [595, 725], [680, 795], [750, 875], [830, 945], [895, 1035], [960, 1080], [1050, 1165], [1080, 1195], [1120, 1245], [1155, 1280], [1315, 1435], [510, 640], [555, 670], [570, 700], [630, 765], [660, 805], [750, 890], [870, 1015], [930, 1065], [1050, 1200], [1095, 1260], [1110, 1260], [1140, 1255], [1170, 1315], [1200, 1320], [1230, 1375]], [[500, 625], [500, 620], [535, 640], [595, 725], [680, 795], [750, 875], [830, 945], [895, 1035], [960, 1080], [1050, 1165], [1080, 1195], [1120, 1245], [1155, 1280], [1315, 1435], [510, 640], [555, 670], [570, 700], [630, 765], [660, 805], [750, 890], [870, 1015], [930, 1065], [1050, 1200], [1095, 1260], [1110, 1260], [1140, 1255], [1170, 1315], [1200, 1320], [1230, 1375]]]

[[[500, 625], [500, 620], [535, 640], [595, 725], [680, 795], [750, 875], [830, 945], [895, 1035], [960, 1080], [1050, 1165], [1080, 1195], [1120, 1245], [1155, 1280], [1315, 1435]], [[510, 640], [555, 670], [570, 700], [630, 765], [660, 805], [750, 890], [870, 1015], [930, 1065], [1050, 1200], [1095, 1260], [1110, 1260], [1140, 1255], [1170, 1315], [1200, 1320], [1230, 1375]]] [[[500, 625], [500, 620], [535, 640], [595, 725], [680, 795], [750, 875], [830, 945], [895, 1035], [960, 1080], [1050, 1165], [1080, 1195], [1120, 1245], [1155, 1280], [1315, 1435]], [[510, 640], [555, 670], [570, 700], [630, 765], [660, 805], [750, 890], [870, 1015], [930, 1065], [1050, 1200], [1095, 1260], [1110, 1260], [1140, 1255], [1170, 1315], [1200, 1320], [1230, 1375]]]


[[[500, 625], [500, 620], [535, 640], [595, 725], [680, 795], [750, 875], [830, 945], [895, 1035], [960, 1080], [1050, 1165], [1080, 1195], [1120, 1245], [1155, 1280], [1315, 1435]], [[510, 640], [555, 670], [570, 700], [630, 765], [660, 805], [750, 890], [870, 1015], [930, 1065], [1050, 1200], [1095, 1260], [1110, 1260], [1140, 1255], [1170, 1315], [1200, 1320], [1230, 1375]]]

Total Flights: [[[730, 845], [880, 985], [895, 1025], [995, 1095], [1100, 1215], [1170, 1270]], [[630, 740], [690, 810], [930, 1040], [975, 1075], [1005, 1105], [1170, 1290]], [[525, 640], [700, 820], [835, 955], [1000, 1115], [1030, 1155], [1245, 1370]]]
from path_find import *
from src.algorithm.data_manager import data_loader
from src.lib.share import *
from ceshi import *

class Flight_Info:
    def __init__(self, loader):
        self.loader = loader  # 存储数据加载器的实例

    def get_flights_for_paths(self, paths):
        all_flight_info = []
        for path in paths:
            flight_info = self.get_flights_between_cities(path)  # 获取航班信息
            all_flight_info.append(flight_info)  # 添加每条路径的航班信息

        return all_flight_info

    def get_flights_between_cities(self, path):
        all_flights = []  # 用于存储该路径下的所有航班信息
        # all_flights.extend([1])
        for i in range(len(path) - 1):
            city_A = path[i]
            city_B = path[i + 1]

            # 获取所有航班信息
            if city_A in self.loader.flights and city_B in self.loader.flights[city_A]:
                flights = self.loader.flights[city_A][city_B]
                all_flights.extend(flights)  # 添加航班信息
                all_flights.extend([1])

        return all_flights  # 返回所有航班信息


class Info:
    def __init__(self, loader):
        self.graph = None
        self.loader = loader  # 存储数据加载器的实例
        self.flight_info = Flight_Info(loader)  # 实例化航班信息类
        self.total = []

    def compute(self, a, b):
        self.graph = Graph(a, b)

    def sort(self):
        self.graph.backup.sort(key=lambda path: (len(path), path))

    def find(self):
        for res in self.graph.backup:
            # self.graph.outputs(res)  # 输出当前路径
            flight_info_for_path = self.flight_info.get_flights_for_paths([res])

            # 存储当前部分的航班信息
            total_flights = []
            single_flights = []
            current_flights = []

            if flight_info_for_path:
                for flights in flight_info_for_path:
                    for flight in flights:
                        if flight == 1:  # 遇到1，输出并清空当前部分
                            for f in current_flights:
                                dep_time = f[0]
                                arr_time = f[3]
                                a1, a2 = dep_time.hour, dep_time.minute
                                b1, b2 = arr_time.hour, arr_time.minute
                                example = [60 * a1 + a2, 60 * b1 + b2]
                                single_flights.append(example)

                            total_flights.append(single_flights.copy())
                            single_flights.clear()  # 清空 single_flights
                            current_flights.clear()  # 清空当前部分
                        else:
                            # 存储航班信息
                            current_flights.append(flight)
                # print("Total Flights:", total_flights)  # 调试打印
                if len(res) == 2:
                    self.findelse2(total_flights, res)
                else:
                    self.findelse(total_flights, res)

    def findelse(self, total_flight, res):

        cunchures2 = []
        for i in range(len(total_flight) - 1):
            cunchures1 = []  # 在每次外层循环开始时初始化
            for j in range(len(total_flight[i])):
                for k in range(len(total_flight[i + 1])):
                    if total_flight[i + 1][k][0] - total_flight[i][j][1] >= 60:
                        cunchures1.append([i, i + 1, j, k])
            cunchures2.append(cunchures1)  # 将当前的 cunchures1 添加到 cunchures2

        # print(len(cunchures2))
        has_empty_list = any(len(sublist) == 0 for sublist in cunchures2)
        if not has_empty_list:
            result = find_valid_routes(cunchures2)
            if result:
                print(res)
            thisinfo = []
            for route in result:
                for i in range(len(route)):
                    a, b = route[i][0], route[i][2]
                    c, d = route[i][1], route[i][3]
                    f1, f2 = res[a], res[a + 1]
                    f3, f4 = res[c], res[c + 1]
                    if [f1, f2, b] not in thisinfo:
                        thisinfo.append([f1, f2, b])
                    if [f3, f4, d] not in thisinfo:
                        thisinfo.append([f3, f4, d])
                # print(route)
                print(thisinfo)
                # self.total.append(thisinfo)
                # print(self.total)
                thisinfo.clear()

    def findelse2(self, total_flight, res):
        print(res)
        thisinfo2 = []
        for i in range(len(total_flight[0])):
            a, b = res[0], res[1]
            thisinfo2.append([a, b, i])
            print(thisinfo2)
            # self.total.extend(thisinfo2)
            # print(self.total)
            thisinfo2.clear()

    def outputs(self):
        print(self.total)


if __name__ == "__main__":
    directory = share.directory  # 替换为你的目录
    loader = data_loader(directory)  # 创建数据加载器实例
    loader.load_flights_info()  # 加载航班信息

    info = Info(loader)  # 创建 Info 实例，并传入数据加载器
    info.compute(11, 3)  # 计算路径
    info.sort()  # 排序路径
    info.find()  # 输出路径及其航班信息
    # info.outputs()


    from IPython.external.qt_for_kernel import QtCore
from PyQt5.QtWidgets import QWidget, QApplication
from PyQt5.QtCore import QTimer, QPointF, Qt
from PyQt5.QtGui import QPixmap, QPainter, QPen, QColor
import sys
import math

class FlightMap(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(100, 100, 1600, 800)
        self.setWindowTitle("动态航线显示")

        # 加载地图图片
        self.pixmap = QPixmap(r"C:\Users\Lenovo\PycharmProjects\BJUT_dsc\data\images\background2.png")

        # 设置航线起点和终点
        self.start_pos = QPointF(580, 200)  # 北京的地图坐标
        self.end_pos = QPointF(120, 150)  # 纽约的地图坐标
        self.current_pos = QPointF(self.start_pos)  # 当前动态绘制的点，从起点开始

        # 设置计时器用于动态绘制
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.updateFlightPath)
        self.timer.start(30)  # 每30毫秒更新一次

        self.isFlying = True  # 添加一个标志来控制是否正在绘制航线

        self.show()

    def updateFlightPath(self):
        # 计算当前点到终点的距离
        dx = self.end_pos.x() - self.current_pos.x()
        dy = self.end_pos.y() - self.current_pos.y()
        distance = math.sqrt(dx ** 2 + dy ** 2)

        # 判断是否到达终点
        if distance > 5:
            # 计算每次前进的步长，更新 current_pos
            step_size = 5  # 控制航线绘制的速度
            self.current_pos.setX(self.current_pos.x() + dx / distance * step_size)
            self.current_pos.setY(self.current_pos.y() + dy / distance * step_size)
        else:
            # 到达终点，停止计时器
            self.timer.stop()
            self.isFlying = False  # 设置标志为False，停止绘制

        # 只有在航线仍在绘制时才调用 update
        if self.isFlying:
            self.update()  # 重新触发绘制

    def paintEvent(self, event):
        super().paintEvent(event)
        painter = QPainter(self)

        # 绘制地图
        painter.drawPixmap(0, 0, self.pixmap)  # 将地图绘制到窗口

        # 设置绘制航线的画笔
        pen = QPen(QColor(173, 216, 230), 4)  # 浅蓝色（RGB: 173, 216, 230），粗细为4
        painter.setPen(pen)

        # 绘制从起点到当前点的航线
        if self.isFlying:
            painter.drawLine(self.start_pos, self.current_pos)
        else:
            painter.drawLine(self.start_pos, self.end_pos)  # 当航线绘制完成，直接绘制从起点到终点的线

        painter.end()  # 结束绘图


if __name__ == '__main__':
    QtCore.QCoreApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling)
    app = QApplication(sys.argv)
    ex = FlightMap()
    sys.exit(app.exec_())


 self.china_map = [
            [3, 947, 396],
            [4, 637, 663],
            [5, 1106, 265],
            [9, 1010, 602],
            [10, 1010, 795],
            [11, 1070, 663],
            [12, 913, 855],
            [14, 313, 301],
            [15, 841, 626],
            [16, 745, 566]
        ]

 from random import random

from IPython.external.qt_for_kernel import QtCore
from PyQt5.QtGui import QPainter, QPen, QPixmap
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget, QPushButton, QHBoxLayout, QTableWidgetItem, \
    QMessageBox, QTableWidget
from PyQt5.uic import loadUi
from boltons.funcutils import partial

from src.QT_src.change import changeWindow
from src.lib.share import *


class userInfo(QMainWindow):
    def __init__(self):
        super().__init__()
        self.ui = loadUi(share.UserInfo_ui, self)
        self.setup_user_info()
        self.pixmap = None

        self.china_map = [
            [3, 947, 396],
            [4, 637, 663],
            [5, 1106, 265],
            [9, 1010, 602],
            [10, 1010, 795],
            [11, 1070, 663],
            [12, 913, 855],
            [14, 313, 301],
            [15, 841, 626],
            [16, 745, 566]
        ]


    def setup_user_info(self):
        layout = QVBoxLayout()
        widgets_to_remove = []

        for widget in self.ui.scrollArea.widget().findChildren(QWidget):
            widgets_to_remove.append(widget)

        for widget in widgets_to_remove:
            widget.deleteLater()

        for idx, flights in enumerate(share.user_flights):
            if flights and any(flight is not None for flight in flights):
                widget = QWidget()
                card_layout = QVBoxLayout(widget)

                table = self.create_flight_table(flights, idx)
                card_layout.addWidget(table)

                button_layout = QHBoxLayout()

                refund_button = QPushButton("退票")
                refund_button.clicked.connect(partial(self.refund_ticket_group, idx))
                button_layout.addWidget(refund_button)

                change_button = QPushButton("改签")
                change_button.clicked.connect(partial(self.change_ticket_group, idx))
                button_layout.addWidget(change_button)

                route_button = QPushButton("航线")
                route_button.clicked.connect(partial(self.view_route, idx))
                button_layout.addWidget(route_button)

                card_layout.addLayout(button_layout)

                layout.addWidget(widget)

        self.ui.scrollArea.widget().setLayout(layout)
        self.ui.scrollArea.setWidgetResizable(True)

        # 添加判断条件，更新map标签的图片并绘制内容


    def create_flight_table(self, flights, user_idx):
        table = QTableWidget(len(flights), 8)
        table.setHorizontalHeaderLabels(
            ["信息编号", "出发时间", "出发机场", "飞行时间", "到达时间", "到达机场", "航班信息", "票价"])

        table.setColumnWidth(0, 100)
        table.setColumnWidth(1, 100)
        table.setColumnWidth(2, 120)
        table.setColumnWidth(3, 100)
        table.setColumnWidth(4, 100)
        table.setColumnWidth(5, 120)
        table.setColumnWidth(6, 120)
        table.setColumnWidth(7, 100)

        table.setFixedHeight(160)

        row_height = 40
        for row, flight in enumerate(flights):
            if flight is None:
                continue

            departure_time, departure_airport, duration, arrival_time, arrival_airport, flight_number, price = flight
            table.setItem(row, 0, QTableWidgetItem(f"0000{random.randint(0, 9999):04d}"))
            table.setItem(row, 1, QTableWidgetItem(departure_time.strftime('%H:%M')))
            table.setItem(row, 2, QTableWidgetItem(departure_airport))
            table.setItem(row, 3, QTableWidgetItem(duration))
            table.setItem(row, 4, QTableWidgetItem(arrival_time.strftime('%H:%M')))
            table.setItem(row, 5, QTableWidgetItem(arrival_airport))
            table.setItem(row, 6, QTableWidgetItem(flight_number))
            table.setItem(row, 7, QTableWidgetItem(f"¥{price}"))

            table.setRowHeight(row, row_height)

        return table

    def refund_ticket_group(self, user_idx):
        share.user_flights[user_idx] = [None] * len(share.user_flights[user_idx])
        self.setup_user_info()
        QMessageBox.information(self, "退票成功", "航班已退票！")

    def change_ticket_group(self, user_idx):
        self.close()
        change_window = changeWindow(share.num_flights[user_idx], user_idx, self)
        change_window.show()

    def update_flight_info(self, user_idx, flights):
        share.user_flights[user_idx] = flights
        self.setup_user_info()

    def view_route(self, user_idx):
        self.update_map_image(share.condition)

    def update_map_image(self, condition):

        if condition == 0:
            self.pixmap = QPixmap(r'C:\Users\Lenovo\PycharmProjects\BJUT_dsc\data\images\background2.png')
        elif condition == 1:
            self.pixmap = QPixmap(r'C:\Users\Lenovo\PycharmProjects\BJUT_dsc\data\images\cmap.png')
        self.printmap(0, 0, 1250, 1000)

    def printmap(self, x1, y1, x2, y2):
        # 现在开始在图片上绘制
        painter = QPainter(self.pixmap)

        # 设置画笔
        pen = QPen(Qt.blue)  # 设置红色画笔
        pen.setWidth(5)  # 设置画笔宽度
        pen.setStyle(Qt.DashLine)  # 设置画笔样式为虚线
        painter.setPen(pen)

        # 在图片上绘制线条
        painter.drawLine(x1, y1, x2, y2)

        painter.end()  # 结束绘制

        # 更新QLabel显示的pixmap
        self.ui.map.setPixmap(self.pixmap)
        self.ui.map.setScaledContents(True)

if __name__ == "__main__":
    import sys
    QtCore.QCoreApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling)
    app = QApplication(sys.argv)
    window = userInfo()
    window.show()
    sys.exit(app.exec_())
